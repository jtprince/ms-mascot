require 'external'

module Ms
  module Mascot
    module Dat
      
      # Provides array-like access to an mgf archival file.
      class Archive < ExternalArchive
        module Utils
          module_function
          
          # Parses a hash of metadata (content_type, boundary, etc) from io.
          # parse_metadata does not reposition io.
          def parse_metadata(io)
            current_pos = io.pos
            io.rewind
            
            metadata = {}
            line = io.readline
            unless line =~ /MIME-Version: (\d+\.\d+) \(Generated by Mascot version (\d+\.\d+)\)/
              raise "could not parse mime-version or mascot-version: #{line}"
            end
            metadata[:mime_version] = $1
            metadata[:mascot_version] = $2
            
            line = io.readline
            unless line =~ /Content-Type: (.*?); boundary=(.*)/
              raise "could not parse content-type: #{line}"
            end
            metadata[:content_type] = $1
            metadata[:boundary] = $2
            
            io.pos = current_pos
            metadata
          end
          
          # Parses a mascot-style content type declaration.  This method is
          # very brittle, but works for all known dat files.
          def parse_content_type(str)
            unless str =~ /^Content-Type: (.*?); name=\"(.*)\"/
              raise "unparseable content-type declaration: #{str}"
            end
            
            {:content_type => $1, :name => $2}
          end
          
          def content_type(metadata)
            const_name = metadata[:name].camelize
            unless metadata[:content_type] == 'application/x-Mascot' && Dat.const_defined?(const_name)
              raise "unknown content_type: #{metadata.inspect}"
            end

            Dat.const_get(const_name)
          end
        end
        
        include Utils
        
        # A hash of metadata associated with this dat file.
        attr_reader :metadata
        
        # An array of section names associated with each entry in self.
        # Section names are determined dynamically when accessed through
        # the section_name method.
        attr_reader :section_names
        
        def initialize(io=nil, io_index=nil)
          super(io)
          @metadata = parse_metadata(io)
          @section_names = []
        end
        
        # The boundary separating sections, typically '--gc0p4Jq0M2Yt08jU534c0p'.
        def boundary
          "--#{metadata[:boundary]}"
        end
        
        # Reindexes self.
        def reindex(&block)
          @section_names.clear
          reindex_by_sep(boundary, :entry_follows_sep => true, &block)
        end
        
        # Converts str into an entry according to the content type header
        # which should be present at the start of the string.
        def str_to_entry(str)
          metadata = parse_content_type(str)
          content_type(metadata).parse(str)
        end
        
        # Returns the entry for the named section.
        def section(name)
          self[section_index(name)]
        end
        
        # Returns the index of the named section.
        def section_index(name)
          0.upto(length) do |index|
            return index if section_name(index) == name
          end
          nil
        end
        
        # Returns the section name for the entry at index.  Undetermined
        # section names are parsed from the entry's Content-Type header.
        def section_name(index)
          @section_names[index] ||= parse_section_name(index)
        end
        
        private
        
        # helper to go to the entry at index and parse the section name
        def parse_section_name(index) # :nodoc:
          entry_start, entry_length = io_index[index]
          io.pos = entry_start + metadata[:boundary].length + 2
          parse_content_type(io.readline)[:name]
        end
      end
    end
  end
end