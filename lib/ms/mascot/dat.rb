require 'ms/mascot/dat/query'

module Ms
  module Mascot
    class Dat

      # A hash of (section_name, SectionClass) pairs mapping section names
      # to section class.  Initially SectionClass may be a require path; if
      # so the path is required and the class looked up like:
      #
      #   Ms::Mascot::Dat.const_get(section_name.capitalize)
      #
      # Such that 'header' is mapped to Ms::Mascot::Dat::Header.
      CONTENT_TYPE_CLASSES = {}

      # currently unimplemented: unimod enzyme taxonomy mixture quantitation
      %w{header index masses parameters peptides proteins summary query
      }.each do |section_name|
        CONTENT_TYPE_CLASSES[section_name] = "ms/mascot/dat/#{section_name}"
      end

      class << self
        def open(filename, &block)
          File.open(filename) do |io|
            block.call(Ms::Mascot::Dat.new(io))
          end
        end

        MascotSection_re = /Content-Type: application\/x-Mascot; name="(\w+)"/o
        QueryMatch_re = /query(\d+)/o
        ParamMatch_re = /(\w+)=(.*)/o

        # Parses a hash of metadata (content_type, boundary, etc) from io.
        # parse_metadata does not reposition io.
        def parse_metadata(io)
          # Simon Chiang wrote this
          current_pos = io.pos
          io.rewind

          metadata = {}
          line = io.readline
          unless line =~ /MIME-Version: (\d+\.\d+) \(Generated by Mascot version (\d+\.\d+)\)/
            raise "could not parse mime-version or mascot-version: #{line}"
          end
          metadata[:mime_version] = $1
          metadata[:mascot_version] = $2

          line = io.readline
          unless line =~ /Content-Type: (.*?); boundary=(.*)/
            raise "could not parse content-type: #{line}"
          end
          metadata[:content_type] = $1
          metadata[:boundary] = $2

          io.pos = current_pos
          metadata
        end

        # Parses a mascot-style content type declaration.  This method uses
        # a simple regexp and is very brittle, but it works for all known
        # dat files.
        def parse_content_type(str)
          unless str =~ /^Content-Type: (.*?); name=\"(.*)\"/
            raise "unparseable content-type declaration: #{str.inspect}"
          end

          {:content_type => $1, :section_name => $2}
        end

        # Resolves a content type class from a hash of metadata like:
        #
        #   metadata = {
        #     :content_type => 'application/x-Mascot',
        #     :section_name => 'header'
        #   }
        #   Dat.content_type_class(metadata)   # => Ms::Mascot::Dat::Header
        #
        # Raises an error if the content type is not 'application/x-Mascot'
        # or if the name is not registered in CONTENT_TYPE_CLASSES.
        def content_type_class(name)
          name = 'query' if name =~ /^query(\d+)$/
            case const = CONTENT_TYPE_CLASSES[name]
            when String
              require const
              CONTENT_TYPE_CLASSES[name] = Dat.const_get(name.capitalize)
            else
              const
            end
        end

        # Converts str into an entry according to the content type header
        # which should be present at the start of the string.
        def str_to_entry(str)
          if ctc = content_type_class(parse_content_type(str))
            ctc.parse(str, self)
          else
            str
          end
        end

        # returns [section_names_array, {'<type>' => [start_byte, num_bytes]}]
        # type is one of: parameters, masses, unimod, enzyme, header, summary,
        # decoy_summary, peptides, proteins, index  (maybe more of
        # these, but it will get them too)
        # NOTE: the key 'query' returns an array indexed on query number
        #   eg: index['parameters']  # -> [70, 211]
        #       index['query']       # -> [[3001,70], [3071,80], [3152,75]...]
        #       index['query'][75]   # -> [8542,93] # start & length for query 75
        # REWINDS the io
        def parse_index(io)  # :nodoc:
          ar = []
          section_names = []
          # get the boundary size and advance io to start
          io.gets
          bound_size = io.gets.match(/boundary=(.*)/)[1].size + 4

          ar = []
          io.each("\n") do |line|
            if md = MascotSection_re.match(line) 
              ar << [md[1], line.size, io.pos]
            end
          end
          hash = {}
          # add a placeholder in order to process the last one
          ar << ['--placeholder--', 2, io.pos]
          query_ar = []
          ar.each_with_index do |lil_ar, i|
            next if ar[i+1].nil?
            (a,b) = lil_ar, ar[i+1]
            key = a.first
            section_names << key
            value = [a.last+1, (b.last - a.last) - (bound_size + b[1])]
            if md = QueryMatch_re.match(key)
              query_ar[md[1].to_i] = value
            else
              hash[key] = value
            end
          end
          hash['query'] = query_ar if query_ar.size > 0
          io.rewind
          [section_names, hash]
        end

      end # class methods

      # the io object given to the new method
      attr_reader :io

      # (mainly for internal use), a hash keyed by dat section with values that
      # are each a little array: [start_byte, num_bytes]
      attr_reader :byte_index

      attr_accessor :section_names

      # should probably use Dat.open(filename, &block) rather than this.
      def initialize(io) # :nodoc:
        @io = io
        (@section_names, @byte_index) = Ms::Mascot::Dat.parse_index(io)
        @query_index_ar = @byte_index['query']
      end

      def section(name)
        if @byte_index.key?(name)
          str = read_section(@byte_index[name])
          if ctc = Ms::Mascot::Dat.content_type_class(name)
            ctc.parse(str, name, self)
          else
            str
          end
        else
          nil
        end
      end

      # (safely) assumes that the first query is query1 and there are no
      # skipped queries
      def nqueries
        @query_index_ar.size - 1
      end

      def each_query(&block)
        @query_index_ar.each_with_index do |ind_ar, i|
          if ind_ar
            block.call Ms::Mascot::Dat::Query.parse(read_section(ind_ar), i, self)
          end
        end
      end

      # these are retrieved by the query number (which typically starts at 1,
      # rather than 0)
      #     query(0)   # -> nil
      #     query(1)   # -> (bona fide query object)
      def query(num)
        ind_ar = @query_index_ar[num]
        if ind_ar 
          Ms::Mascot::Dat::Query.parse( read_section(ind_ar), num, self)
        else ; nil
        end
      end

      # Returns an array of query objects
      #
      #     Dat.open(file) do |dat|
      #       dat.queries   # -> all queries (use each_query if memory is issue)
      #     end
      def queries
        qrs = []
        self.each_query {|qr| qrs << qr }
        qrs
      end


      # by default, yields the top PeptideHit object per query
      # opts may be:
      #     :by => :top
      #       :top     top ranked hit (default)
      #       :groups  an array of hits
      #       :all     each peptide hit (all ranks)
      #
      #     :yield_nil => true 
      #       true     returns nil when a query had no peptide hit (default)
      #       false    this hit (or group) is not yielded
      #     :with_query => false
      #       false    just returns peptide hits/groups (default) 
      #       true     yields the peptide_hit/group and associated query
      def each_peptide_hit(opts={})
        defaults = { :by => :top, :yield_nil => true, :with_query => false }
        (by, yield_nil, with_query) = defaults.merge(opts).values_at(:by, :yield_nil, :with_query)

        peptides = section('peptides')
        1.upto(nqueries) do |n|
          case by
          when :top
            hit = peptides.peptide_hit(n)
            unless !yield_nil && hit.nil?
              if with_query
                yield hit, query(n)
              else
                yield hit
              end
            end
          when :groups
            group = peptides.peptide_hits(n)
            group.shift # remove the 0 index
            unless !yield_nil && group.first.nil?
              if with_query
                yield group, query(n)
              else
                yield group
              end
            end
          when :all

            group = peptides.peptide_hits(n)
            group.shift # remove the 0 index
            unless !yield_nil && group.first.nil?
              # need to return the nil hit if we are yielding nils:
              if group.first.nil?
                if with_query
                  yield nil, query(n)
                else
                  yield nil
                end
              end
              group.each do |pep_hit|
                if with_query
                  yield pep_hit, query(n)
                else
                  yield pep_hit
                end
              end
            end
          end
        end
      end


      # Returns a string
      # takes an ar: [pos, length]
      def read_section(ar) # :nodoc:
        @io.pos = ar.first
        @io.read(ar.last)
      end

    end
  end
end


