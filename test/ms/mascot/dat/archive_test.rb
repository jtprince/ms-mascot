require File.join(File.dirname(__FILE__), '../../../tap_test_helper.rb') 
require 'ms/mascot/dat/archive'
require 'stringio'

class DatArchiveUtilsTest < Test::Unit::TestCase
  include Ms::Mascot::Dat::Archive::Utils
  
  #
  # parse_metadata test
  #
  
  def test_parse_metadata_parses_metadata_from_io
    str =  "MIME-Version: 1.0 (Generated by Mascot version 1.0)\n"
    str += "Content-Type: multipart/mixed; boundary=gc0p4Jq0M2Yt08jU534c0p\n"
    io = StringIO.new str
    
    assert_equal({
      :mime_version => '1.0',
      :mascot_version => '1.0',
      :content_type => 'multipart/mixed',
      :boundary => 'gc0p4Jq0M2Yt08jU534c0p'
    }, parse_metadata(io))
  end
  
  def test_parse_metadata_does_not_reposition_io
    str =  "MIME-Version: 1.0 (Generated by Mascot version 1.0)\n"
    str += "Content-Type: multipart/mixed; boundary=gc0p4Jq0M2Yt08jU534c0p\n"
    io = StringIO.new str
    io.pos = 10
    
    assert_equal "gc0p4Jq0M2Yt08jU534c0p", parse_metadata(io)[:boundary]
    assert_equal 10, io.pos
  end
  
  #
  # parse_content_type test
  #
  
  def test_parse_content_type
    assert_equal({
      :content_type => 'application/x-Mascot',
      :name => 'unimod'
    }, parse_content_type('Content-Type: application/x-Mascot; name="unimod"'))
  end
end

class DatArchiveTest < Test::Unit::TestCase
  include Ms::Mascot::Dat
  
  acts_as_file_test
  
  MODEL_DAT = %Q{
MIME-Version: 1.0 (Generated by Mascot version 1.0)
Content-Type: multipart/mixed; boundary=gc0p4Jq0M2Yt08jU534c0p

--gc0p4Jq0M2Yt08jU534c0p
Content-Type: application/x-Mascot; name="one"

section one
content
--gc0p4Jq0M2Yt08jU534c0p
Content-Type: application/x-Mascot; name="two"

section two
content
--gc0p4Jq0M2Yt08jU534c0p--
}.strip

  attr_accessor :io
  
  def setup
    super
    @io = StringIO.new(MODEL_DAT)
  end
  
  #
  # initialize test
  #
  
  def test_initialize_parses_metadata
    dat = Archive.new(io)
    assert_equal({
      :mime_version => '1.0',
      :mascot_version => '1.0',
      :content_type => 'multipart/mixed',
      :boundary => 'gc0p4Jq0M2Yt08jU534c0p'
    }, dat.metadata)
  end
  
  #
  # boundary test
  #
  
  def test_boundary_is_metadata_boundary_formatted_as_multipart_form_boundary
    dat = Archive.new(io)
    assert_equal "--gc0p4Jq0M2Yt08jU534c0p", dat.boundary
  end
  
  #
  # reindex test
  #
  
  def test_reindex_indexes_based_on_boundary
    dat = Archive.new(io)
    dat.reindex
    
    assert_equal 2, dat.length
    assert_equal %Q{

Content-Type: application/x-Mascot; name="one"

section one
content
}, "\n" + dat[0]

    assert_equal %Q{

Content-Type: application/x-Mascot; name="two"

section two
content
}, "\n" + dat[1]
  end
  
  def test_reindex_returns_self
    dat = Archive.new(io)
    assert_equal dat, dat.reindex
  end
  
  #
  # section_index test
  #
  
  def test_section_index_returns_index_of_named_section
    dat = Archive.new(io).reindex
    assert_equal 1, dat.section_index("two")
    assert_equal 0, dat.section_index("one")
  end
  
  def test_section_index_returns_nil_for_unknown_section
    dat = Archive.new(io).reindex
    assert_equal nil, dat.section_index("unknown")
  end
  
  #
  # section_name test
  #
  
  def test_section_name_returns_name_of_section_at_index
    dat = Archive.new(io).reindex
    assert_equal "two", dat.section_name(1)
    assert_equal "one", dat.section_name(0)
  end
  
  def test_section_name_works_for_negative_indicies
    dat = Archive.new(io).reindex
    assert_equal "two", dat.section_name(-1)
  end
  
  def test_section_name_returns_nil_for_section_out_of_range
    dat = Archive.new(io).reindex
    assert_equal 2, dat.length
    assert_equal nil, dat.section_name(10)
  end
end